/**
\file  CaPTkSurvivalPredictionAlgorithm.h

\brief The header file containing the CaPTkSurvivalPredictionAlgorithm class, used to build machine learning models
Library Dependecies: ITK 4.7+ <br>

https://www.med.upenn.edu/sbia/software/ <br>
software@cbica.upenn.edu

Copyright (c) 2016 University of Pennsylvania. All rights reserved. <br>
See COPYING file or https://www.med.upenn.edu/sbia/software-agreement.html

*/
#ifndef CaPTkSurvivalPredictionAlgorithm_h
#define CaPTkSurvivalPredictionAlgorithm_h

// The following header file is generated by CMake and thus it's located in
// the build directory. It provides an export macro for classes and functions
// that you want to be part of the public interface of your module.
#include <MitkCaPTkSurvivalExports.h>

#include <string>
#include <QString>
#include <QFileInfo>

#include "itkCSVArray2DFileReader.h"
#include "itkImage.h"
#include "itkRescaleIntensityImageFilter.h"
#include "itkImageFileReader.h"
#include "itkConnectedComponentImageFilter.h"
#include "itkCastImageFilter.h"
#include "itkSignedMaurerDistanceMapImageFilter.h"

#include "mitkLogMacros.h"

#include "CaPTkFeatureScalingClass.h"
#include "CaPTkFeatureExtractionClass.h"
#include "CaPTkEnums.h"
#include "CaPTkDefines.h"

/**
\class SurvivalPredictionModuleAlgorithm

\brief Calculates Survival Prediction Index

Reference:

@article{macyszyn2015imaging,
title={Imaging patterns predict patient survival and molecular subtype in glioblastoma via machine learning techniques},
author={Macyszyn, Luke and Akbari, Hamed and Pisapia, Jared M and Da, Xiao and Attiah, Mark and Pigrish, Vadim and Bi, Yingtao and Pal, Sharmistha and Davuluri, Ramana V and Roccograndi, Laura and others},
journal={Neuro-oncology},
volume={18},
number={3},
pages={417--425},
year={2015},
publisher={Society for Neuro-Oncology}
}

*/


// pre-calculated values
#define SURVIVAL_MODEL6_RHO		-1.0927
#define SURVIVAL_MODEL6_G		0.0313
#define SURVIVAL_MODEL18_RHO	-0.2854
#define SURVIVAL_MODEL18_G		0.5

#define SURVIVAL_SIZE_COMP 100
#define SURVIVAL_NO_NEAR_DIST 100


namespace captk
{
class MITKCAPTKSURVIVAL_EXPORT SurvivalPredictionModuleAlgorithm
{
public:
  /**** Types ****/
    typedef itk::Image< float, 3 > ImageType;
    typedef itk::CSVArray2DFileReader<double> CSVFileReaderType;
    typedef vnl_matrix<double> MatrixType;
    typedef itk::VariableLengthVector<double> VariableLengthVectorType;
    typedef std::vector<double> VectorDouble;
    typedef itk::VariableSizeMatrix<double> VariableSizeMatrixType;


  /**** Defaults ****/
  std::string mSixTrainedFile = "Survival_SVM_Model6.xml";
  std::string mEighteenTrainedFile = "Survival_SVM_Model18.xml";

  /**** Public methods ****/

  SurvivalPredictionModuleAlgorithm() {};
  ~SurvivalPredictionModuleAlgorithm() {};

  /** \brief Runs the algorithm
   * 
   * @return first field is true when execution went fine, std::string is the potential error message
   */
  std::tuple<bool, std::string> 
  Run(
          QString modelDir,
          QString subjectDir,
          QString outputDir,
          bool trainNewModel,
          bool useCustomModel,
          QString cbicaModelDir
      );

 /**** Protected methods ****/

protected:

  std::vector<std::map<captk::ImageModalityType, std::string>> LoadQualifiedSubjectsFromGivenDirectory(const std::string directoryname);

  /**
  \brief Calculates the statistcal features (mean, satndard deviation) for given vector

  \param intensities			Input vector having intensities from a region of an image
  */
  VectorDouble GetStatisticalFeatures(const VectorDouble &intensities);



  /**
  \brief Calculates the histogram binning based features for given vector

  \param intensities			Input vector having intensities from a region of an image
  \param start				Start of the histogram bins
  \param interval				Interval between the centers of two hsitogram bins
  \param end					End of the histogram bins
  */
  VectorDouble GetHistogramFeatures(const VectorDouble &intensities, const double &start, const double &interval, const double &end);

  /**
  \brief Calculates volumetric measures adn their ratios

  \param edemaSize			Volume of edema in terms of number of voxels
  \param tuSize				Volume of enhancing tumor in terms of number of voxels
  \param neSize				Volume of non-enahancing tumro core in terms of number of voxels
  \param totalSize			Volume of whoe brain in terms of number of voxels
  */
  VectorDouble GetVolumetricFeatures(const double &edemaSize, const double &tuSize, const double &neSize, const double &totalSize);

  /**
  \brief Prepares a new survival prediction model

  \param inputdirectory			Path to the directory having training data
  \param qualifiedsubjects		List of qualifeid subjects having all the data avaialble to train a model
  \param outputdirectory			Path to the output directory
  */
  int PrepareNewSurvivalPredictionModel(
      const std::string &inputdirectory,
      const std::vector< std::map< ImageModalityType, std::string > > &qualifiedsubjects,
      const std::string &outputdirectory);

  /**
  \brief Apply an exsiting model on new patients to predict survival

  \param modeldirectory			Path to the directory where model fiels are stored
  \param inputdirectory			Path to the directory having test data
  \param qualifiedsubjects		List of qualifeid subjects having all the data avaialble to apply a model
  \param outputdirectory			Path to the output directory
  */
  VectorDouble SurvivalPredictionOnExistingModel(const std::string &modeldirectory,
    const std::string &inputdirectory,
    const std::vector< std::map< ImageModalityType, std::string > > &qualifiedsubjects,
    const std::string &outputdirectory);

  void CallForSurvivalPredictionOnExistingModel(const std::string modeldirectory, const std::string inputdirectory, const std::string outputdirectory);
  void CallForNewSurvivalPredictionModel(const std::string inputdirectory, const std::string outputdirectory);

  VariableSizeMatrixType SelectSixMonthsModelFeatures(const VariableSizeMatrixType &SixModelFeatures);
  VariableSizeMatrixType SelectEighteenMonthsModelFeatures(const VariableSizeMatrixType &EighteenModelFeatures);



  VariableLengthVectorType DistanceFunction(const VariableSizeMatrixType &testData, const std::string &filename, const double &rho, const double &bestg);
  VectorDouble CombineEstimates(const VariableLengthVectorType &estimates1, const VariableLengthVectorType &estimates2);
  VectorDouble CombineEstimates(const VectorDouble &estimates1, const VectorDouble &estimates2);

  void WriteCSVFiles(VariableSizeMatrixType inputdata, std::string filepath);


  /**** Templated Function Definitions ****/

  /**
  \brief Calculates the features for given images of one subject

  \param t1ceImagePointer			Pointer to T1CE image
  \param t2flairImagePointer		Pointer to T2-FLAIR image
  \param t1ImagePointer			Pointer to T1-weighted image
  \param t2ImagePointer			Pointer to T2 image
  \param rcbvImagePointer			Pointer to RCBV image
  \param psrImagePointer			Pointer to Percent Signal Recovery (PSR) image
  \param phImagePointer			Pointer to Peak Height (PH) image
  \param axImagePointer			Pointer to Axial Diffusivity image
  \param faImagePointer			Pointer to Fractional Anisotropy image
  \param radImagePointer			Pointer to Radial Diffusivity image
  \param trImagePointer			Pointer to Trace image
  \param labelImagePointer		Pointer to image having segmentation labels in patient space
  \param atlasImagePointer		Pointer to image having segmentation labels in atla space
  \param templateImagePointer		Pointer to atlas to calculate location features
  \param configuration			Configurations for calculation of histogram features
  */

  template<class ImageType>
  double SurvivalEstimateOnGivenSubject(typename ImageType::Pointer LabelImagePointer,
      typename ImageType::Pointer AtlasImagePointer,
      typename ImageType::Pointer TemplateImagePointer,
      typename ImageType::Pointer T1CEImagePointer,
      typename ImageType::Pointer T2FlairImagePointer,
      typename ImageType::Pointer T1ImagePointer,
      typename ImageType::Pointer T2ImagePointer,
      typename ImageType::Pointer PHImagePointer,
      typename ImageType::Pointer PSRImagePointer,
      typename ImageType::Pointer RCBVImagePointer,
      typename ImageType::Pointer AXImagePointer,
      typename ImageType::Pointer FAImagePointer,
      typename ImageType::Pointer RADImagePointer,
      typename ImageType::Pointer TRImagePointer, int age, std::string modeldirectory)
  {
      FeatureScalingClass featureScalingLocalPtr;
      VariableSizeMatrixType HistogramFeaturesConfigurations;
      HistogramFeaturesConfigurations.SetSize(33, 3); //11 modalities*3 regions = 33 configurations*3 histogram features for each configuration

      CSVFileReaderType::Pointer reader = CSVFileReaderType::New();
      VectorDouble ages;
      MatrixType dataMatrix;
      try
      {
          reader->SetFileName(modeldirectory + "/Survival_HMFeatures_Configuration.csv");
          reader->SetFieldDelimiterCharacter(',');
          reader->HasColumnHeadersOff();
          reader->HasRowHeadersOff();
          reader->Parse();
          dataMatrix = reader->GetArray2DDataObject()->GetMatrix();

          for (unsigned int i = 0; i < dataMatrix.rows(); i++)
              for (unsigned int j = 0; j < dataMatrix.cols(); j++)
                  HistogramFeaturesConfigurations(i, j) = dataMatrix(i, j);
      }
      catch (const std::exception& e1)
      {
          MITK_ERROR << "Cannot find the file 'Survival_HMFeatures_Configuration.csv' in the input directory. Error code : " + std::string(e1.what());
          throw std::string(e1.what()); // propagate error string to algorithm-running logic
      }
      MatrixType meanMatrix;
      VariableLengthVectorType mean;
      VariableLengthVectorType stddevition;
      try
      {
          reader->SetFileName(modeldirectory + "/Survival_ZScore_Mean.csv");
          reader->SetFieldDelimiterCharacter(',');
          reader->HasColumnHeadersOff();
          reader->HasRowHeadersOff();
          reader->Parse();
          meanMatrix = reader->GetArray2DDataObject()->GetMatrix();

          mean.SetSize(meanMatrix.size());
          for (unsigned int i = 0; i < meanMatrix.size(); i++)
              mean[i] = meanMatrix(i, 0);
      }
      catch (const std::exception& e1)
      {
          MITK_ERROR << "Cannot find the file 'mean.csv' in the model directory. Error code : " + std::string(e1.what());
          throw std::string(e1.what()); // propagate error string to algorithm-running logic
      }
      MatrixType stdMatrix;
      try
      {
          reader->SetFileName(modeldirectory + "/Survival_ZScore_Std.csv");
          reader->SetFieldDelimiterCharacter(',');
          reader->HasColumnHeadersOff();
          reader->HasRowHeadersOff();
          reader->Parse();
          stdMatrix = reader->GetArray2DDataObject()->GetMatrix();

          stddevition.SetSize(stdMatrix.size());
          for (unsigned int i = 0; i < stdMatrix.size(); i++)
              stddevition[i] = stdMatrix(i, 0);
      }
      catch (const std::exception& e1)
      {
          MITK_ERROR << "Cannot find the file 'std.csv' in the model directory. Error code : " + std::string(e1.what());
          throw std::string(e1.what()); // propagate error string to algorithm-running logic
      }
      //----------------------------------------------------
      VariableSizeMatrixType FeaturesOfAllSubjects;
      FeaturesOfAllSubjects.SetSize(1, 161);

      VectorDouble TestFeatures = LoadTestData<ImageType>(T1CEImagePointer, T2FlairImagePointer, T1ImagePointer,
          T2ImagePointer, RCBVImagePointer, PSRImagePointer, PHImagePointer, AXImagePointer, FAImagePointer,
          RADImagePointer, TRImagePointer, LabelImagePointer, AtlasImagePointer, TemplateImagePointer,
          HistogramFeaturesConfigurations);

      FeaturesOfAllSubjects(0, 0) = age;
      for (unsigned int i = 1; i <= TestFeatures.size(); i++)
          FeaturesOfAllSubjects(0, i) = TestFeatures[i - 1];

      VariableSizeMatrixType ScaledTestingData = featureScalingLocalPtr.ScaleGivenTestingFeatures(FeaturesOfAllSubjects, mean, stddevition);
      VariableSizeMatrixType ScaledFeatureSetAfterAddingLabel;
      ScaledFeatureSetAfterAddingLabel.SetSize(ScaledTestingData.Rows(), ScaledTestingData.Cols() + 1);
      for (unsigned int i = 0; i < ScaledTestingData.Rows(); i++)
      {
          unsigned int j = 0;
          for (j = 0; j < ScaledTestingData.Cols(); j++)
              ScaledFeatureSetAfterAddingLabel(i, j) = ScaledTestingData(i, j);
          ScaledFeatureSetAfterAddingLabel(i, j) = 0;
      }

      VariableSizeMatrixType SixModelSelectedFeatures = SelectSixMonthsModelFeatures(ScaledFeatureSetAfterAddingLabel);
      VariableSizeMatrixType EighteenModelSelectedFeatures = SelectEighteenMonthsModelFeatures(ScaledFeatureSetAfterAddingLabel);
      VectorDouble results;

      try
      {
          VariableLengthVectorType result_6;
          VariableLengthVectorType result_18;
          if (QFileInfo::exists(QString::fromStdString(modeldirectory + "/Survival_SVM_Model6.csv")) == true
                  && QFileInfo::exists(QString::fromStdString(modeldirectory + "/Survival_SVM_Model18.csv")) == true)
          {
                result_6 = DistanceFunction(SixModelSelectedFeatures, modeldirectory + "/Survival_SVM_Model6.csv",
                SURVIVAL_MODEL6_RHO, // value calculated to be -1.0927
                SURVIVAL_MODEL6_G // value calculated to be 0.0313
            );
                result_18 = DistanceFunction(EighteenModelSelectedFeatures, modeldirectory + "/Survival_SVM_Model18.csv",
                SURVIVAL_MODEL18_RHO, // value calculated to be -0.2854
                SURVIVAL_MODEL18_G // value calculated to be 0.5
            );
          }
          else
          {
              MITK_ERROR<< "Error caught during testing: There is no existing model file in the model directory: " + modeldirectory;
              throw std::string("No existing model file in directory " + modeldirectory); // propagate error message
          }

          results = CombineEstimates(result_6, result_18);

      }
      catch (itk::ExceptionObject & excp)
      {
          MITK_ERROR << "Error caught during testing: " + std::string(excp.GetDescription());
          throw std::string(excp.what()); // propagate error string to algorithm-running logic
      }
      return results[0];
  }



  template<class ImageType>
  VectorDouble  LoadTestData(const typename ImageType::Pointer &t1ceImagePointer,
      const typename ImageType::Pointer &t2flairImagePointer,
      const typename ImageType::Pointer &t1ImagePointer,
      const typename ImageType::Pointer &t2ImagePointer,
      const typename ImageType::Pointer &rcbvImagePointer,
      const typename ImageType::Pointer &psrImagePointer,
      const typename ImageType::Pointer &phImagePointer,
      const typename ImageType::Pointer &axImagePointer,
      const typename ImageType::Pointer &faImagePointer,
      const typename ImageType::Pointer &radImagePointer,
      const typename ImageType::Pointer &trImagePointer,
      const typename ImageType::Pointer &labelImagePointer,
      const typename ImageType::Pointer &atlasImagePointer,
      const typename ImageType::Pointer &templateImagePointer,
      const VariableSizeMatrixType &configuration)
  {
      std::vector<typename ImageType::IndexType> edemaIndices;
      std::vector<typename ImageType::IndexType> etumorIndices;
      std::vector<typename ImageType::IndexType> tumorIndices;
      std::vector<typename ImageType::IndexType> necoreIndices;
      std::vector<typename ImageType::IndexType> brainIndices;
      std::vector<typename ImageType::IndexType> ventIndices;

      VectorDouble tumorIntensitiesT1;
      VectorDouble tumorIntensitiesT2;
      VectorDouble tumorIntensitiesT1CE;
      VectorDouble tumorIntensitiesT2Flair;
      VectorDouble tumorIntensitiesAX;
      VectorDouble tumorIntensitiesFA;
      VectorDouble tumorIntensitiesRAD;
      VectorDouble tumorIntensitiesTR;
      VectorDouble tumorIntensitiesRCBV;
      VectorDouble tumorIntensitiesPSR;
      VectorDouble tumorIntensitiesPH;

      VectorDouble edemaIntensitiesT1;
      VectorDouble edemaIntensitiesT2;
      VectorDouble edemaIntensitiesT1CE;
      VectorDouble edemaIntensitiesT2Flair;
      VectorDouble edemaIntensitiesAX;
      VectorDouble edemaIntensitiesFA;
      VectorDouble edemaIntensitiesRAD;
      VectorDouble edemaIntensitiesTR;
      VectorDouble edemaIntensitiesRCBV;
      VectorDouble edemaIntensitiesPSR;
      VectorDouble edemaIntensitiesPH;

      VectorDouble necoreIntensitiesT1;
      VectorDouble necoreIntensitiesT2;
      VectorDouble necoreIntensitiesT1CE;
      VectorDouble necoreIntensitiesT2Flair;
      VectorDouble necoreIntensitiesAX;
      VectorDouble necoreIntensitiesFA;
      VectorDouble necoreIntensitiesRAD;
      VectorDouble necoreIntensitiesTR;
      VectorDouble necoreIntensitiesRCBV;
      VectorDouble necoreIntensitiesPSR;
      VectorDouble necoreIntensitiesPH;




      typedef itk::ImageRegionIteratorWithIndex <ImageType> IteratorType;
      IteratorType imIt(labelImagePointer, labelImagePointer->GetLargestPossibleRegion());
      imIt.GoToBegin();
      while (!imIt.IsAtEnd())
      {
          if (imIt.Get() == captk::GLISTR_OUTPUT_LABELS::TUMOR)
              etumorIndices.push_back(imIt.GetIndex());
          else if (imIt.Get() == captk::GLISTR_OUTPUT_LABELS::NONENHANCING)
              necoreIndices.push_back(imIt.GetIndex());
          else if (imIt.Get() == captk::GLISTR_OUTPUT_LABELS::EDEMA)
              edemaIndices.push_back(imIt.GetIndex());
          else if (imIt.Get() == captk::GLISTR_OUTPUT_LABELS::VENT)
              ventIndices.push_back(imIt.GetIndex());
          else
          {
          }
          if (imIt.Get() > captk::GLISTR_OUTPUT_LABELS::ALL)
              brainIndices.push_back(imIt.GetIndex());
          if (imIt.Get() == captk::GLISTR_OUTPUT_LABELS::TUMOR || imIt.Get() == captk::GLISTR_OUTPUT_LABELS::NONENHANCING)
              tumorIndices.push_back(imIt.GetIndex());
          ++imIt;
      }
      for (unsigned int i = 0; i < etumorIndices.size(); i++)
      {
          tumorIntensitiesT1.push_back(std::round(t1ImagePointer.GetPointer()->GetPixel(etumorIndices[i])));
          tumorIntensitiesT2.push_back(std::round(t2ImagePointer.GetPointer()->GetPixel(etumorIndices[i])));
          tumorIntensitiesT1CE.push_back(std::round(t1ceImagePointer.GetPointer()->GetPixel(etumorIndices[i])));
          tumorIntensitiesT2Flair.push_back(std::round(t2flairImagePointer.GetPointer()->GetPixel(etumorIndices[i])));
          tumorIntensitiesAX.push_back(std::round(axImagePointer.GetPointer()->GetPixel(etumorIndices[i])));
          tumorIntensitiesFA.push_back(std::round(faImagePointer.GetPointer()->GetPixel(etumorIndices[i])));
          tumorIntensitiesRAD.push_back(std::round(radImagePointer.GetPointer()->GetPixel(etumorIndices[i])));
          tumorIntensitiesTR.push_back(std::round(trImagePointer.GetPointer()->GetPixel(etumorIndices[i])));
          tumorIntensitiesRCBV.push_back(std::round(rcbvImagePointer.GetPointer()->GetPixel(etumorIndices[i])));
          tumorIntensitiesPSR.push_back(std::round(psrImagePointer.GetPointer()->GetPixel(etumorIndices[i])));
          tumorIntensitiesPH.push_back(phImagePointer.GetPointer()->GetPixel(etumorIndices[i]));
      }

      for (unsigned int i = 0; i < edemaIndices.size(); i++)
      {
          edemaIntensitiesT1.push_back(std::round(t1ImagePointer.GetPointer()->GetPixel(edemaIndices[i])));
          edemaIntensitiesT2.push_back(std::round(t2ImagePointer.GetPointer()->GetPixel(edemaIndices[i])));
          edemaIntensitiesT1CE.push_back(std::round(t1ceImagePointer.GetPointer()->GetPixel(edemaIndices[i])));
          edemaIntensitiesT2Flair.push_back(std::round(t2flairImagePointer.GetPointer()->GetPixel(edemaIndices[i])));
          edemaIntensitiesAX.push_back(std::round(axImagePointer.GetPointer()->GetPixel(edemaIndices[i])));
          edemaIntensitiesFA.push_back(std::round(faImagePointer.GetPointer()->GetPixel(edemaIndices[i])));
          edemaIntensitiesRAD.push_back(std::round(radImagePointer.GetPointer()->GetPixel(edemaIndices[i])));
          edemaIntensitiesTR.push_back(std::round(trImagePointer.GetPointer()->GetPixel(edemaIndices[i])));
          edemaIntensitiesRCBV.push_back(std::round(rcbvImagePointer.GetPointer()->GetPixel(edemaIndices[i])));
          edemaIntensitiesPSR.push_back(std::round(psrImagePointer.GetPointer()->GetPixel(edemaIndices[i])));
          edemaIntensitiesPH.push_back(phImagePointer.GetPointer()->GetPixel(edemaIndices[i]));
      }

      for (unsigned int i = 0; i < necoreIndices.size(); i++)
      {
          necoreIntensitiesT1.push_back(std::round(t1ImagePointer.GetPointer()->GetPixel(necoreIndices[i])));
          necoreIntensitiesT2.push_back(std::round(t2ImagePointer.GetPointer()->GetPixel(necoreIndices[i])));
          necoreIntensitiesT1CE.push_back(std::round(t1ceImagePointer.GetPointer()->GetPixel(necoreIndices[i])));
          necoreIntensitiesT2Flair.push_back(std::round(t2flairImagePointer.GetPointer()->GetPixel(necoreIndices[i])));
          necoreIntensitiesAX.push_back(std::round(axImagePointer.GetPointer()->GetPixel(necoreIndices[i])));
          necoreIntensitiesFA.push_back(std::round(faImagePointer.GetPointer()->GetPixel(necoreIndices[i])));
          necoreIntensitiesRAD.push_back(std::round(radImagePointer.GetPointer()->GetPixel(necoreIndices[i])));
          necoreIntensitiesTR.push_back(std::round(trImagePointer.GetPointer()->GetPixel(necoreIndices[i])));
          necoreIntensitiesRCBV.push_back(std::round(rcbvImagePointer.GetPointer()->GetPixel(necoreIndices[i])));
          necoreIntensitiesPSR.push_back(std::round(psrImagePointer.GetPointer()->GetPixel(necoreIndices[i])));
          necoreIntensitiesPH.push_back(phImagePointer.GetPointer()->GetPixel(necoreIndices[i]));
      }

      //------------------------------------------------------get histogram and statistics features-------------------
      VectorDouble TumorBinsT1 = GetHistogramFeatures(tumorIntensitiesT1, configuration(0,0), configuration(0,1), configuration(0,2));
      VectorDouble TumorBinsT2 = GetHistogramFeatures(tumorIntensitiesT2, configuration(1,0), configuration(1,1), configuration(1,2));
      VectorDouble TumorBinsT1CE = GetHistogramFeatures(tumorIntensitiesT1CE, configuration(2, 0), configuration(2, 1), configuration(2, 2));
      VectorDouble TumorBinsT2Flair = GetHistogramFeatures(tumorIntensitiesT2Flair, configuration(3, 0), configuration(3, 1), configuration(3,2));
      VectorDouble TumorBinsAX = GetHistogramFeatures(tumorIntensitiesAX, configuration(4, 0), configuration(4, 1), configuration(4,2));
      VectorDouble TumorBinsFA = GetHistogramFeatures(tumorIntensitiesFA, configuration(5, 0), configuration(5, 1), configuration(5,2));
      VectorDouble TumorBinsRAD = GetHistogramFeatures(tumorIntensitiesRAD, configuration(6, 0), configuration(6, 1), configuration(6,2));
      VectorDouble TumorBinsTR = GetHistogramFeatures(tumorIntensitiesTR, configuration(7, 0), configuration(7, 1), configuration(7,2));
      VectorDouble TumorBinsRCBV = GetHistogramFeatures(tumorIntensitiesRCBV, configuration(8, 0), configuration(8, 1), configuration(8,2));
      VectorDouble TumorBinsPSR = GetHistogramFeatures(tumorIntensitiesPSR, configuration(9, 0), configuration(9, 1), configuration(9,2));
      VectorDouble TumorBinsPH = GetHistogramFeatures(tumorIntensitiesPH, configuration(10, 0), configuration(10, 1), configuration(10, 2));

      VectorDouble edemaBinsT1 = GetHistogramFeatures(edemaIntensitiesT1, configuration(11, 0), configuration(11, 1), configuration(11, 2));
      VectorDouble edemaBinsT2 = GetHistogramFeatures(edemaIntensitiesT2, configuration(12, 0), configuration(12, 1), configuration(12, 2));
      VectorDouble edemaBinsT1CE = GetHistogramFeatures(edemaIntensitiesT1CE, configuration(13, 0), configuration(13, 1), configuration(13, 2));
      VectorDouble edemaBinsT2Flair = GetHistogramFeatures(edemaIntensitiesT2Flair, configuration(14, 0), configuration(14, 1), configuration(14, 2));
      VectorDouble edemaBinsAX = GetHistogramFeatures(edemaIntensitiesAX, configuration(15, 0), configuration(15, 1), configuration(15, 2));
      VectorDouble edemaBinsFA = GetHistogramFeatures(edemaIntensitiesFA, configuration(16, 0), configuration(16, 1), configuration(16, 2));
      VectorDouble edemaBinsRAD = GetHistogramFeatures(edemaIntensitiesRAD, configuration(17, 0), configuration(17, 1), configuration(17, 2));
      VectorDouble edemaBinsTR = GetHistogramFeatures(edemaIntensitiesTR, configuration(18, 0), configuration(18, 1), configuration(18, 2));
      VectorDouble edemaBinsRCBV = GetHistogramFeatures(edemaIntensitiesRCBV, configuration(19, 0), configuration(19, 1), configuration(19, 2));
      VectorDouble edemaBinsPSR = GetHistogramFeatures(edemaIntensitiesPSR, configuration(20, 0), configuration(20, 1), configuration(20, 2));
      VectorDouble edemaBinsPH = GetHistogramFeatures(edemaIntensitiesPH, configuration(21, 0), configuration(21, 1), configuration(21, 2));

      VectorDouble necoreBinsT1 = GetHistogramFeatures(necoreIntensitiesT1, configuration(22, 0), configuration(22, 1), configuration(22, 2));
      VectorDouble necoreBinsT2 = GetHistogramFeatures(necoreIntensitiesT2, configuration(23, 0), configuration(23, 1), configuration(23, 2));
      VectorDouble necoreBinsT1CE = GetHistogramFeatures(necoreIntensitiesT1CE, configuration(24, 0), configuration(24, 1), configuration(24, 2));
      VectorDouble necoreBinsT2Flair = GetHistogramFeatures(necoreIntensitiesT2Flair, configuration(25, 0), configuration(25, 1), configuration(25, 2));
      VectorDouble necoreBinsAX = GetHistogramFeatures(necoreIntensitiesAX, configuration(26, 0), configuration(26, 1), configuration(26, 2));
      VectorDouble necoreBinsFA = GetHistogramFeatures(necoreIntensitiesFA, configuration(27, 0), configuration(27, 1), configuration(27, 2));
      VectorDouble necoreBinsRAD = GetHistogramFeatures(necoreIntensitiesRAD, configuration(28, 0), configuration(28, 1), configuration(28, 2));
      VectorDouble necoreBinsTR = GetHistogramFeatures(necoreIntensitiesTR, configuration(29, 0), configuration(29, 1), configuration(29, 2));
      VectorDouble necoreBinsRCBV = GetHistogramFeatures(necoreIntensitiesRCBV, configuration(30, 0), configuration(30, 1), configuration(30, 2));
      VectorDouble necoreBinsPSR = GetHistogramFeatures(necoreIntensitiesPSR, configuration(31, 0), configuration(31, 1), configuration(31, 2));
      VectorDouble necoreBinsPH = GetHistogramFeatures(necoreIntensitiesPH, configuration(32, 0), configuration(32, 1), configuration(32, 2));

      VectorDouble TumorStatisticsT1 = GetStatisticalFeatures(tumorIntensitiesT1);
      VectorDouble TumorStatisticsT2 = GetStatisticalFeatures(tumorIntensitiesT2);
      VectorDouble TumorStatisticsT1CE = GetStatisticalFeatures(tumorIntensitiesT1CE);
      VectorDouble TumorStatisticsT2Flair = GetStatisticalFeatures(tumorIntensitiesT2Flair);
      VectorDouble TumorStatisticsAX = GetStatisticalFeatures(tumorIntensitiesAX);
      VectorDouble TumorStatisticsFA = GetStatisticalFeatures(tumorIntensitiesFA);
      VectorDouble TumorStatisticsRAD = GetStatisticalFeatures(tumorIntensitiesRAD);
      VectorDouble TumorStatisticsTR = GetStatisticalFeatures(tumorIntensitiesTR);
      VectorDouble TumorStatisticsRCBV = GetStatisticalFeatures(tumorIntensitiesRCBV);
      VectorDouble TumorStatisticsPSR = GetStatisticalFeatures(tumorIntensitiesPSR);
      VectorDouble TumorStatisticsPH = GetStatisticalFeatures(tumorIntensitiesPH);

      VectorDouble edemaStatisticsT1 = GetStatisticalFeatures(edemaIntensitiesT1);
      VectorDouble edemaStatisticsT2 = GetStatisticalFeatures(edemaIntensitiesT2);
      VectorDouble edemaStatisticsT1CE = GetStatisticalFeatures(edemaIntensitiesT1CE);
      VectorDouble edemaStatisticsT2Flair = GetStatisticalFeatures(edemaIntensitiesT2Flair);
      VectorDouble edemaStatisticsAX = GetStatisticalFeatures(edemaIntensitiesAX);
      VectorDouble edemaStatisticsFA = GetStatisticalFeatures(edemaIntensitiesFA);
      VectorDouble edemaStatisticsRAD = GetStatisticalFeatures(edemaIntensitiesRAD);
      VectorDouble edemaStatisticsTR = GetStatisticalFeatures(edemaIntensitiesTR);
      VectorDouble edemaStatisticsRCBV = GetStatisticalFeatures(edemaIntensitiesRCBV);
      VectorDouble edemaStatisticsPSR = GetStatisticalFeatures(edemaIntensitiesPSR);
      VectorDouble edemaStatisticsPH = GetStatisticalFeatures(edemaIntensitiesPH);

      VectorDouble necoreStatisticsT1 = GetStatisticalFeatures(necoreIntensitiesT1);
      VectorDouble necoreStatisticsT2 = GetStatisticalFeatures(necoreIntensitiesT2);
      VectorDouble necoreStatisticsT1CE = GetStatisticalFeatures(necoreIntensitiesT1CE);
      VectorDouble necoreStatisticsT2Flair = GetStatisticalFeatures(necoreIntensitiesT2Flair);
      VectorDouble necoreStatisticsAX = GetStatisticalFeatures(necoreIntensitiesAX);
      VectorDouble necoreStatisticsFA = GetStatisticalFeatures(necoreIntensitiesFA);
      VectorDouble necoreStatisticsRAD = GetStatisticalFeatures(necoreIntensitiesRAD);
      VectorDouble necoreStatisticsTR = GetStatisticalFeatures(necoreIntensitiesTR);
      VectorDouble necoreStatisticsRCBV = GetStatisticalFeatures(necoreIntensitiesRCBV);
      VectorDouble necoreStatisticsPSR = GetStatisticalFeatures(necoreIntensitiesPSR);
      VectorDouble necoreStatisticsPH = GetStatisticalFeatures(necoreIntensitiesPH);

      //-------------------------------Find connected components and get volumetric features -----------------------------
      std::vector<typename ImageType::Pointer> RevisedImages = RevisedTumorArea<ImageType>(labelImagePointer);
      typename ImageType::Pointer tumorImage = RevisedImages[0];
      typename ImageType::Pointer etumorImage = RevisedImages[1];
      typename ImageType::Pointer ncrImage = RevisedImages[2];

      etumorIndices.clear();
      necoreIndices.clear();
      tumorIndices.clear();


      IteratorType ncrIt(ncrImage, ncrImage->GetLargestPossibleRegion());
      ncrIt.GoToBegin();
      while (!ncrIt.IsAtEnd())
      {
          if (ncrIt.Get() == captk::VOXEL_STATUS::ON)
              necoreIndices.push_back(ncrIt.GetIndex());
          ++ncrIt;
      }
      IteratorType etIt(etumorImage, etumorImage->GetLargestPossibleRegion());
      etIt.GoToBegin();
      while (!etIt.IsAtEnd())
      {
          if (etIt.Get() == captk::VOXEL_STATUS::ON)
              etumorIndices.push_back(etIt.GetIndex());
          ++etIt;
      }
      IteratorType tumorIt(tumorImage, tumorImage->GetLargestPossibleRegion());
      tumorIt.GoToBegin();
      while (!tumorIt.IsAtEnd())
      {
          if (tumorIt.Get() == captk::VOXEL_STATUS::ON)
              tumorIndices.push_back(tumorIt.GetIndex());
          ++tumorIt;
      }
      VectorDouble VolumetricFeatures = GetVolumetricFeatures(edemaIndices.size(), etumorIndices.size(), necoreIndices.size(), brainIndices.size());
      VectorDouble spatialLocationFeatures = GetSpatialLocationFeatures<ImageType>(atlasImagePointer, templateImagePointer);

      //--------------------------------Alternate function for distance features----------------------------------------------
      typename ImageType::Pointer  edemaDistanceMap = GetDistanceMapWithLabel<ImageType>(labelImagePointer, captk::GLISTR_OUTPUT_LABELS::EDEMA);

      typename ImageType::Pointer ventImage = ImageType::New();
      ventImage->CopyInformation(labelImagePointer);
      ventImage->SetRequestedRegion(labelImagePointer->GetLargestPossibleRegion());
      ventImage->SetBufferedRegion(labelImagePointer->GetBufferedRegion());
      ventImage->Allocate();
      ventImage->FillBuffer(0);

      typedef itk::ImageRegionIteratorWithIndex <ImageType> IteratorType;

      IteratorType labelIt(labelImagePointer, labelImagePointer->GetLargestPossibleRegion());
      IteratorType ventIt(ventImage, ventImage->GetLargestPossibleRegion());
      labelIt.GoToBegin();
      ventIt.GoToBegin();
      while (!labelIt.IsAtEnd())
      {
          if (labelIt.Get() == captk::GLISTR_OUTPUT_LABELS::VENT)
              ventIt.Set(captk::VOXEL_STATUS::ON);
          ++labelIt;
          ++ventIt;
      }
      typename ImageType::Pointer  ventDistanceMap = GetDistanceMap<ImageType>(ventImage);
      typename ImageType::Pointer  tumorDistanceMap = GetDistanceMap<ImageType>(tumorImage);

      VectorDouble DistanceFeatures = GetDistanceFeatures3<ImageType>(edemaDistanceMap, tumorDistanceMap, ventDistanceMap);




      //copy data from vectors to one final feature vector
      VectorDouble TestFeatures;
      TestFeatures.insert(TestFeatures.end(), VolumetricFeatures.begin(), VolumetricFeatures.end());
      TestFeatures.insert(TestFeatures.end(), DistanceFeatures.begin(), DistanceFeatures.end());
      TestFeatures.insert(TestFeatures.end(), TumorStatisticsT1CE.begin(), TumorStatisticsT1CE.end());
      TestFeatures.insert(TestFeatures.end(), TumorStatisticsT1.begin(), TumorStatisticsT1.end());
      TestFeatures.insert(TestFeatures.end(), TumorStatisticsT2.begin(), TumorStatisticsT2.end());
      TestFeatures.insert(TestFeatures.end(), TumorStatisticsT2Flair.begin(), TumorStatisticsT2Flair.end());
      TestFeatures.insert(TestFeatures.end(), TumorStatisticsPH.begin(), TumorStatisticsPH.end());
      TestFeatures.insert(TestFeatures.end(), TumorStatisticsPSR.begin(), TumorStatisticsPSR.end());
      TestFeatures.insert(TestFeatures.end(), TumorStatisticsRCBV.begin(), TumorStatisticsRCBV.end());
      TestFeatures.insert(TestFeatures.end(), TumorStatisticsFA.begin(), TumorStatisticsFA.end());
      TestFeatures.insert(TestFeatures.end(), TumorStatisticsAX.begin(), TumorStatisticsAX.end());
      TestFeatures.insert(TestFeatures.end(), TumorStatisticsRAD.begin(), TumorStatisticsRAD.end());
      TestFeatures.insert(TestFeatures.end(), TumorStatisticsTR.begin(), TumorStatisticsTR.end());
      TestFeatures.insert(TestFeatures.end(), TumorBinsT1CE.begin(), TumorBinsT1CE.end());
      TestFeatures.insert(TestFeatures.end(), edemaBinsT1CE.begin(), edemaBinsT1CE.end());
      TestFeatures.insert(TestFeatures.end(), necoreBinsT1CE.begin(), necoreBinsT1CE.end());
      TestFeatures.insert(TestFeatures.end(), TumorBinsT1.begin(), TumorBinsT1.end());
      TestFeatures.insert(TestFeatures.end(), edemaBinsT1.begin(), edemaBinsT1.end());
      TestFeatures.insert(TestFeatures.end(), necoreBinsT1.begin(), necoreBinsT1.end());
      TestFeatures.insert(TestFeatures.end(), TumorBinsT2.begin(), TumorBinsT2.end());
      TestFeatures.insert(TestFeatures.end(), edemaBinsT2.begin(), edemaBinsT2.end());
      TestFeatures.insert(TestFeatures.end(), necoreBinsT2.begin(), necoreBinsT2.end());
      TestFeatures.insert(TestFeatures.end(), TumorBinsT2Flair.begin(), TumorBinsT2Flair.end());
      TestFeatures.insert(TestFeatures.end(), edemaBinsT2Flair.begin(), edemaBinsT2Flair.end());
      TestFeatures.insert(TestFeatures.end(), necoreBinsT2Flair.begin(), necoreBinsT2Flair.end());
      TestFeatures.insert(TestFeatures.end(), TumorBinsPH.begin(), TumorBinsPH.end());
      TestFeatures.insert(TestFeatures.end(), edemaBinsPH.begin(), edemaBinsPH.end());
      TestFeatures.insert(TestFeatures.end(), necoreBinsPH.begin(), necoreBinsPH.end());
      TestFeatures.insert(TestFeatures.end(), TumorBinsPSR.begin(), TumorBinsPSR.end());
      TestFeatures.insert(TestFeatures.end(), edemaBinsPSR.begin(), edemaBinsPSR.end());
      TestFeatures.insert(TestFeatures.end(), necoreBinsPSR.begin(), necoreBinsPSR.end());
      TestFeatures.insert(TestFeatures.end(), TumorBinsRCBV.begin(), TumorBinsRCBV.end());
      TestFeatures.insert(TestFeatures.end(), edemaBinsRCBV.begin(), edemaBinsRCBV.end());
      TestFeatures.insert(TestFeatures.end(), necoreBinsRCBV.begin(), necoreBinsRCBV.end());
      TestFeatures.insert(TestFeatures.end(), TumorBinsFA.begin(), TumorBinsFA.end());
      TestFeatures.insert(TestFeatures.end(), edemaBinsFA.begin(), edemaBinsFA.end());
      TestFeatures.insert(TestFeatures.end(), necoreBinsFA.begin(), necoreBinsFA.end());
      TestFeatures.insert(TestFeatures.end(), TumorBinsAX.begin(), TumorBinsAX.end());
      TestFeatures.insert(TestFeatures.end(), edemaBinsAX.begin(), edemaBinsAX.end());
      TestFeatures.insert(TestFeatures.end(), necoreBinsAX.begin(), necoreBinsAX.end());
      TestFeatures.insert(TestFeatures.end(), TumorBinsRAD.begin(), TumorBinsRAD.end());
      TestFeatures.insert(TestFeatures.end(), edemaBinsRAD.begin(), edemaBinsRAD.end());
      TestFeatures.insert(TestFeatures.end(), necoreBinsRAD.begin(), necoreBinsRAD.end());
      TestFeatures.insert(TestFeatures.end(), TumorBinsTR.begin(), TumorBinsTR.end());
      TestFeatures.insert(TestFeatures.end(), edemaBinsTR.begin(), edemaBinsTR.end());
      TestFeatures.insert(TestFeatures.end(), necoreBinsTR.begin(), necoreBinsTR.end());
      TestFeatures.insert(TestFeatures.end(), spatialLocationFeatures.begin(), spatialLocationFeatures.end());
      return TestFeatures;
  }

  template<class ImageType>
  typename ImageType::Pointer RemoveSmallerComponentsFromTumor(const typename ImageType::Pointer &etumorImage, const typename ImageType::Pointer &ncrImage)
  {
      typename ImageType::Pointer tumorImage = ImageType::New();
      tumorImage->CopyInformation(etumorImage);
      tumorImage->SetRequestedRegion(etumorImage->GetLargestPossibleRegion());
      tumorImage->SetBufferedRegion(etumorImage->GetBufferedRegion());
      tumorImage->Allocate();
      tumorImage->FillBuffer(0);

      typedef itk::ImageRegionIteratorWithIndex <ImageType> IteratorType;
      IteratorType tumorIt(tumorImage, tumorImage->GetLargestPossibleRegion());
      IteratorType ncrIt(ncrImage, ncrImage->GetLargestPossibleRegion());
      IteratorType etIt(etumorImage, etumorImage->GetLargestPossibleRegion());

      tumorIt.GoToBegin();
      etIt.GoToBegin();
      ncrIt.GoToBegin();

      while (!tumorIt.IsAtEnd())
      {
          if (etIt.Get() == captk::VOXEL_STATUS::ON || ncrIt.Get() == captk::VOXEL_STATUS::ON)
              tumorIt.Set(captk::VOXEL_STATUS::ON);
          else
              tumorIt.Set(captk::VOXEL_STATUS::OFF);

          ++tumorIt;
          ++etIt;
          ++ncrIt;
      }

      typedef itk::Image< unsigned short, 3 > OutputImageType;

      typedef itk::ConnectedComponentImageFilter <ImageType, OutputImageType> ConnectedComponentImageFilterType;
      typename ConnectedComponentImageFilterType::Pointer connected = ConnectedComponentImageFilterType::New();
      connected->FullyConnectedOn();
      connected->SetInput(tumorImage);
      connected->Update();
      OutputImageType::Pointer labeledImage = connected->GetOutput();

      connected->GetObjectCount();
      std::vector<int> sizes;
      typedef itk::ImageRegionIteratorWithIndex <OutputImageType> OutputIteratorType;
      OutputIteratorType lbimIt(labeledImage, labeledImage->GetLargestPossibleRegion());

      for (unsigned int i = 0; i < connected->GetObjectCount(); i++)
      {
          int counter = 0;
          lbimIt.GoToBegin();
          while (!lbimIt.IsAtEnd())
          {
              if (lbimIt.Get() == i + 1)
                  counter++;
              ++lbimIt;
          }
          sizes.push_back(counter);
      }
      for (unsigned int i = 0; i < connected->GetObjectCount(); i++)
      {
          if (sizes[i] < SURVIVAL_SIZE_COMP)
          {
              lbimIt.GoToBegin();
              tumorIt.GoToBegin();
              while (!lbimIt.IsAtEnd())
              {
                  if (lbimIt.Get() == i + 1)
                      tumorIt.Set(captk::VOXEL_STATUS::OFF);

                  ++lbimIt;
                  ++tumorIt;
              }
          }
      }
      return tumorImage;
  }


  template <class ImageType>
  typename ImageType::Pointer ReadNiftiImage(const std::string &filename)
  {
      typedef itk::ImageFileReader<ImageType> ImageReaderType;
      typename ImageReaderType::Pointer reader = ImageReaderType::New();
      reader->SetFileName(filename);

      try
      {
          reader->Update();
      }
      catch (itk::ExceptionObject& e)
      {
          MITK_ERROR << "Error caught while reading image: " << e.GetDescription();
          throw std::string(e.what()); // propagate error string to the algorithm-running logic for catching
      }


      return reader->GetOutput();
  }

  template<class ImageType>
  typename ImageType::Pointer RescaleImageIntensity(const typename ImageType::Pointer &image)
  {
      typedef itk::RescaleIntensityImageFilter< ImageType, ImageType > RescaleFilterType;
      typename RescaleFilterType::Pointer rescaleFilter = RescaleFilterType::New();
      rescaleFilter->SetInput(image);
      rescaleFilter->SetOutputMinimum(0);
      rescaleFilter->SetOutputMaximum(255);
      rescaleFilter->Update();
      typename ImageType::Pointer outputimage = rescaleFilter->GetOutput();
      return outputimage;
  }

  /**
  \brief Calculates the spatial location features for given tumor images

  \param labelImagePointer		Pointer to image having segmentation labels in patient space
  \param atlasImagePointer		Pointer to image having segmentation labels in atlas space
  */
  template<class ImageType>
  VectorDouble GetSpatialLocationFeatures(const typename ImageType::Pointer &labelImagePointer, const typename ImageType::Pointer &jacobtemplateImagePointer)
  {
      std::vector<typename ImageType::Pointer> RevisedImages = RevisedTumorArea<ImageType>(labelImagePointer);
      typename ImageType::Pointer tumorImage = RevisedImages[0];
      typename ImageType::Pointer etumorImage = RevisedImages[1];
      typename ImageType::Pointer ncrImage = RevisedImages[2];


      typename ImageType::Pointer localizeImage = ImageType::New();
      localizeImage->CopyInformation(labelImagePointer);
      localizeImage->SetRequestedRegion(labelImagePointer->GetLargestPossibleRegion());
      localizeImage->SetBufferedRegion(labelImagePointer->GetBufferedRegion());
      localizeImage->Allocate();
      localizeImage->FillBuffer(0);

      //mulitply revised tumor image with the atlas ROI image
      typedef itk::ImageRegionIteratorWithIndex <ImageType> IteratorType;
      IteratorType tumorIt(tumorImage, tumorImage->GetLargestPossibleRegion());
      IteratorType localizeIt(localizeImage, localizeImage->GetLargestPossibleRegion());
      IteratorType atlasIt(jacobtemplateImagePointer, jacobtemplateImagePointer->GetLargestPossibleRegion());

      atlasIt.GoToBegin();
      tumorIt.GoToBegin();
      localizeIt.GoToBegin();

      while (!tumorIt.IsAtEnd())
      {
          localizeIt.Set(tumorIt.Get()*atlasIt.Get());
          ++localizeIt;
          ++tumorIt;
          ++atlasIt;
      }
      //find number of voxels in 9 ROIs
      VectorDouble location;
      int tumorSize = 0;
      for (unsigned int i = 0; i < 9; i++)
      {
          int counter = 0;
          localizeIt.GoToBegin();
          while (!localizeIt.IsAtEnd())
          {
              if (localizeIt.Get() == i + 1)
              {
                  counter++;
                  tumorSize++;
              }
              ++localizeIt;
          }
          location.push_back(counter);
      }
      //find percentages in 9 ROIs
      for (unsigned int i = 0; i < 9; i++)
          location[i] = (location[i] * 100) / tumorSize;

      return location;
  }

  /**
  \brief Calculates the distance map of an image by keeping the non-zero voxels of image as reference seed point

  \param image					Pointer to image having reference seed points
  */
  template<class ImageType>
  typename ImageType::Pointer GetDistanceMap(const typename ImageType::Pointer &labelImagePointer)
  {
      typedef itk::Image<unsigned char, 3>  UnsignedCharImageType;
      typedef itk::CastImageFilter< ImageType, UnsignedCharImageType > CastFilterType;
      typename CastFilterType::Pointer castFilter = CastFilterType::New();
      castFilter->SetInput(labelImagePointer);
      typedef  itk::SignedMaurerDistanceMapImageFilter< UnsignedCharImageType, ImageType  > SignedMaurerDistanceMapImageFilterType;
      typename  SignedMaurerDistanceMapImageFilterType::Pointer distanceMapImageFilter = SignedMaurerDistanceMapImageFilterType::New();
      distanceMapImageFilter->SetInput(castFilter->GetOutput());
      distanceMapImageFilter->Update();
      typename ImageType::Pointer DistanceMap = distanceMapImageFilter->GetOutput();
      return DistanceMap;
  }
  /**
  \brief Calculates the distance map of an image by keeping the given label as reference seed point

  \param labelImagePointer		Pointer to image having segmentation labels in patient space
  \param label					Label to use as a reference seed point
  */

  template<class ImageType>
  typename ImageType::Pointer GetDistanceMapWithLabel(const typename ImageType::Pointer &labelImagePointer, const int &label1)
  {
      typename ImageType::Pointer interImage = ImageType::New();
      interImage->CopyInformation(labelImagePointer);
      interImage->SetRequestedRegion(labelImagePointer->GetLargestPossibleRegion());
      interImage->SetBufferedRegion(labelImagePointer->GetBufferedRegion());
      interImage->Allocate();
      interImage->FillBuffer(0);
      typedef itk::ImageRegionIteratorWithIndex <ImageType> IteratorType;
      IteratorType imIt(labelImagePointer, labelImagePointer->GetLargestPossibleRegion());
      IteratorType interIt(interImage, interImage->GetLargestPossibleRegion());
      imIt.GoToBegin();
      interIt.GoToBegin();
      while (!interIt.IsAtEnd())
      {
          if (imIt.Get() == label1)
              interIt.Set(captk::VOXEL_STATUS::ON);
          else
              interIt.Set(captk::VOXEL_STATUS::OFF);
          ++interIt;
          ++imIt;
      }
      typedef itk::Image<unsigned char, 3>  UnsignedCharImageType;
      typedef itk::CastImageFilter< ImageType, UnsignedCharImageType > CastFilterType;
      typename CastFilterType::Pointer castFilter = CastFilterType::New();
      castFilter->SetInput(interImage);
      typedef  itk::SignedMaurerDistanceMapImageFilter< UnsignedCharImageType, ImageType  > SignedMaurerDistanceMapImageFilterType;
      typename  SignedMaurerDistanceMapImageFilterType::Pointer distanceMapImageFilter = SignedMaurerDistanceMapImageFilterType::New();
      distanceMapImageFilter->SetInput(castFilter->GetOutput());
      distanceMapImageFilter->Update();
      typename ImageType::Pointer distanceimage = distanceMapImageFilter->GetOutput();
      return distanceimage;
  }

  /**
  \brief Calculates the distance features. 1. Distanc eof tumro from ventricles, 2. Distance of edema from ventricles

  \param edemaImage		Pointer to image having edema label
  \param tumorImage		Pointer to image having (enhancing tumor + non-enahncign tumor) label
  \param ventImage		Pointer to image having ventricles label
  */
  template<class ImageType>
  VectorDouble GetDistanceFeatures3(const typename ImageType::Pointer &edemaImage, const typename ImageType::Pointer &tumorImage, const typename ImageType::Pointer &ventImage)
  {
      //-----------------------create distance image----------------------------
      VectorDouble VentEdemaSum;
      VectorDouble VentTumorSum;
      //-------------------------get sum of images----------------------------------
      typedef itk::ImageRegionIteratorWithIndex <ImageType> IteratorType;
      IteratorType tumorIt(tumorImage, tumorImage->GetLargestPossibleRegion());
      IteratorType ventIt(ventImage, ventImage->GetLargestPossibleRegion());
      IteratorType edemaIt(edemaImage, edemaImage->GetLargestPossibleRegion());

      tumorIt.GoToBegin();
      ventIt.GoToBegin();
      edemaIt.GoToBegin();

      while (!tumorIt.IsAtEnd())
      {
          VentEdemaSum.push_back(edemaIt.Get() + ventIt.Get());
          VentTumorSum.push_back(tumorIt.Get() + ventIt.Get());
          ++tumorIt;
          ++ventIt;
          ++edemaIt;
      }
      std::sort(VentEdemaSum.begin(), VentEdemaSum.end());
      std::sort(VentTumorSum.begin(), VentTumorSum.end());

      double sumVentEdema = 0;
      double sumVentTumor = 0;
      for (int i = 0; i < SURVIVAL_NO_NEAR_DIST; i++)
      {
          sumVentEdema = sumVentEdema + VentEdemaSum[i];
          sumVentTumor = sumVentTumor + VentTumorSum[i];
      }
      VectorDouble DistanceFeatures;
      DistanceFeatures.push_back(sumVentEdema / SURVIVAL_NO_NEAR_DIST);
      DistanceFeatures.push_back(sumVentTumor / SURVIVAL_NO_NEAR_DIST);

      return DistanceFeatures;
  }


  /**
  \brief Removes the connected components smaller than an area threshold from the tumor

  \param labelImagePointer		Pointer to image having segmentation labels in patient space
  */
  template<class ImageType>
  std::vector<typename ImageType::Pointer> RevisedTumorArea(const typename ImageType::Pointer &labelImagePointer)
  {
      std::vector<typename ImageType::Pointer> RevisedImages;

      typename ImageType::Pointer tumorImage = ImageType::New();
      tumorImage->CopyInformation(labelImagePointer);
      tumorImage->SetRequestedRegion(labelImagePointer->GetLargestPossibleRegion());
      tumorImage->SetBufferedRegion(labelImagePointer->GetBufferedRegion());
      tumorImage->Allocate();
      tumorImage->FillBuffer(0);

      typename ImageType::Pointer etumorImage = ImageType::New();
      etumorImage->CopyInformation(labelImagePointer);
      etumorImage->SetRequestedRegion(labelImagePointer->GetLargestPossibleRegion());
      etumorImage->SetBufferedRegion(labelImagePointer->GetBufferedRegion());
      etumorImage->Allocate();
      etumorImage->FillBuffer(0);

      typename ImageType::Pointer ncrImage = ImageType::New();
      ncrImage->CopyInformation(labelImagePointer);
      ncrImage->SetRequestedRegion(labelImagePointer->GetLargestPossibleRegion());
      ncrImage->SetBufferedRegion(labelImagePointer->GetBufferedRegion());
      ncrImage->Allocate();
      ncrImage->FillBuffer(0);


      typedef itk::ImageRegionIteratorWithIndex <ImageType> IteratorType;
      IteratorType imIt(labelImagePointer, labelImagePointer->GetLargestPossibleRegion());
      IteratorType ncrIt(ncrImage, ncrImage->GetLargestPossibleRegion());
      IteratorType etIt(etumorImage, etumorImage->GetLargestPossibleRegion());
      IteratorType tumorIt(tumorImage, tumorImage->GetLargestPossibleRegion());
      imIt.GoToBegin();
      tumorIt.GoToBegin();
      etIt.GoToBegin();
      ncrIt.GoToBegin();

      while (!tumorIt.IsAtEnd())
      {
          if (imIt.Get() == captk::GLISTR_OUTPUT_LABELS::TUMOR || imIt.Get() == captk::GLISTR_OUTPUT_LABELS::NONENHANCING)
              tumorIt.Set(captk::VOXEL_STATUS::ON);
          else
              tumorIt.Set(captk::VOXEL_STATUS::OFF);

          if (imIt.Get() == captk::GLISTR_OUTPUT_LABELS::TUMOR)
              etIt.Set(captk::VOXEL_STATUS::ON);
          else
              etIt.Set(captk::VOXEL_STATUS::OFF);

          if (imIt.Get() == captk::GLISTR_OUTPUT_LABELS::NONENHANCING)
              ncrIt.Set(captk::VOXEL_STATUS::ON);
          else
              ncrIt.Set(captk::VOXEL_STATUS::OFF);

          ++tumorIt;
          ++etIt;
          ++imIt;
          ++ncrIt;
      }

      typedef itk::Image< unsigned short, 3 > OutputImageType;

      typedef itk::ConnectedComponentImageFilter <ImageType, OutputImageType> ConnectedComponentImageFilterType;
      typename ConnectedComponentImageFilterType::Pointer connected = ConnectedComponentImageFilterType::New();
      connected->FullyConnectedOn();
      connected->SetInput(tumorImage);
      connected->Update();
      OutputImageType::Pointer labeledImage = connected->GetOutput();

      connected->GetObjectCount();
      std::vector<int> sizes;
      typedef itk::ImageRegionIteratorWithIndex <OutputImageType> OutputIteratorType;
      OutputIteratorType lbimIt(labeledImage, labeledImage->GetLargestPossibleRegion());

      for (unsigned int i = 0; i < connected->GetObjectCount(); i++)
      {
          int counter = 0;
          lbimIt.GoToBegin();
          while (!lbimIt.IsAtEnd())
          {
              if (lbimIt.Get() == i + 1)
                  counter++;
              ++lbimIt;
          }
          sizes.push_back(counter);
      }
      for (unsigned int i = 0; i < connected->GetObjectCount(); i++)
      {
          if (sizes[i] < SURVIVAL_SIZE_COMP)
          {
              lbimIt.GoToBegin();
              tumorIt.GoToBegin();
              while (!lbimIt.IsAtEnd())
              {
                  if (lbimIt.Get() == i + 1)
                      tumorIt.Set(captk::VOXEL_STATUS::OFF);
                  ++lbimIt;
                  ++tumorIt;
              }
          }
      }
      tumorIt.GoToBegin();
      etIt.GoToBegin();
      ncrIt.GoToBegin();

      while (!tumorIt.IsAtEnd())
      {
          etIt.Set(etIt.Get()*tumorIt.Get());
          ncrIt.Set(ncrIt.Get()*tumorIt.Get());

          ++tumorIt;
          ++etIt;
          ++ncrIt;
      }
      RevisedImages.push_back(tumorImage);
      RevisedImages.push_back(etumorImage);
      RevisedImages.push_back(ncrImage);

      return RevisedImages;
  }

}; // end class definition


}; // end namespace captk






#endif // ! CaPTkSurvivalPredictionAlgorithm_h
